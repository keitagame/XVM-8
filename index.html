<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>XVM-8S 仕様書</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
    }
    @font-face {
        font-family: "Renner";
        src: url("./Renner.ttf") format("truetype");
        font-display: swap;
      }
    body {
      background: #000;
      font-family: "Renner",sans-serif;
      margin: 0;
      padding: 20px;
      color: #fff;
      line-height: 1.6;
    }
    h1 {
      font-size: 28px;
      font-weight: 300;
      border-bottom: 2px solid #0f0;
      padding-bottom: 10px;
    }
    h2 {
      font-size: 22px;
      font-weight: 400;
      color: #0ff;
      margin-top: 40px;
    }
    h3 {
      font-size: 18px;
      font-weight: 400;
      color: #ff0;
      margin-top: 30px;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    th, td {
      border: 1px solid #444;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background: #1a1a1a;
      font-weight: 500;
    }
    code {
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }
    pre {
      background: #0f0f0f;
      border: 1px solid #333;
      padding: 15px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    .note {
      background: #1a1a00;
      border-left: 4px solid #ff0;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .important {
      background: #1a0000;
      border-left: 4px solid #f00;
      padding: 12px 15px;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>XVM-8S 仕様書</h1>
    <p style="color: #888;">超シンプルな8bitバーチャルマシン - グラフィック専用版</p>

    <div class="note">
      <strong>コンセプト:</strong> 初心者が1日で実装できる最小限のバーチャルマシン。グラフィック描画のみに特化し、命令数は20個以下。
    </div>

    <h2>1. 基本仕様</h2>
    
    <h3>CPU</h3>
    <ul>
      <li>8bit CPU</li>
      <li>アドレス空間: 16bit (64KB)</li>
      <li>クロック: 1MHz / リフレッシュ: 60Hz</li>
    </ul>

    <h3>レジスタ</h3>
    <table>
      <tr><th>名前</th><th>サイズ</th><th>説明</th></tr>
      <tr><td><code>A</code></td><td>8bit</td><td>汎用レジスタ</td></tr>
      <tr><td><code>B</code></td><td>8bit</td><td>汎用レジスタ</td></tr>
      <tr><td><code>X</code></td><td>8bit</td><td>インデックスレジスタ</td></tr>
      <tr><td><code>PC</code></td><td>16bit</td><td>プログラムカウンタ（初期値: 0xE000）</td></tr>
      <tr><td><code>F</code></td><td>8bit</td><td>フラグ（bit0=Zero）</td></tr>
    </table>

    <h3>メモリマップ</h3>
    <table>
      <tr><th>アドレス</th><th>サイズ</th><th>説明</th></tr>
      <tr><td>0x0000-0x7FFF</td><td>32KB</td><td>RAM</td></tr>
      <tr><td>0x8000-0xBFFF</td><td>16KB</td><td><strong>VRAM（グラフィック専用）</strong></td></tr>
      <tr><td>0xC000-0xC00F</td><td>16B</td><td>パレット（16色）</td></tr>
      <tr><td>0xE000-0xFFFF</td><td>8KB</td><td>ROM（プログラム領域）</td></tr>
    </table>

    <h2>2. グラフィック仕様</h2>

    <h3>画面</h3>
    <ul>
      <li>解像度: <strong>128x128 ピクセル</strong></li>
      <li>色数: <strong>16色</strong>（4bit インデックスカラー）</li>
      <li>VRAM配置: <code>VRAM[y * 128 + x]</code> = 色番号（0-15）</li>
    </ul>

    <h3>カラーパレット</h3>
    <p>16色のパレットは <code>0xC000-0xC00F</code> に配置。各色は8bit RGB332形式:</p>
    <pre>RGB332形式:
RRR GGG BB
|||  |  ||
|||  |  ++-- 青 (0-3)  ×85 → 0-255
|||  +------ 緑 (0-7)  ×36 → 0-252
+++--------- 赤 (0-7)  ×36 → 0-252</pre>

    <div class="note">
      <strong>デフォルトパレット:</strong><br>
      0: 0x00 (黒), 1: 0xFF (白), 2: 0xE0 (赤), 3: 0x1C (緑), 
      4: 0x03 (青), 5: 0xFC (黄), 6: 0xE3 (マゼンタ), 7: 0x1F (シアン),
      8-15: 0x00 (初期は黒)
    </div>

    <h2>3. 命令セット（最小構成）</h2>

    <table>
      <thead>
        <tr><th>命令</th><th>コード</th><th>サイクル</th><th>説明</th></tr>
      </thead>
      <tbody>
        <tr><td>NOP</td><td>0x00</td><td>1</td><td>何もしない</td></tr>
        <tr><td>LD A, #n</td><td>0x01 nn</td><td>2</td><td>A = n</td></tr>
        <tr><td>LD B, #n</td><td>0x02 nn</td><td>2</td><td>B = n</td></tr>
        <tr><td>LD X, #n</td><td>0x03 nn</td><td>2</td><td>X = n</td></tr>
        <tr><td>LD A, [addr]</td><td>0x04 LL HH</td><td>3</td><td>A = メモリ[addr]</td></tr>
        <tr><td>ST A, [addr]</td><td>0x05 LL HH</td><td>3</td><td>メモリ[addr] = A</td></tr>
        <tr><td>MOV A, B</td><td>0x10</td><td>1</td><td>A = B</td></tr>
        <tr><td>MOV B, A</td><td>0x11</td><td>1</td><td>B = A</td></tr>
        <tr><td>MOV A, X</td><td>0x12</td><td>1</td><td>A = X</td></tr>
        <tr><td>MOV X, A</td><td>0x13</td><td>1</td><td>X = A</td></tr>
        <tr><td>ADD A, B</td><td>0x20</td><td>1</td><td>A = A + B</td></tr>
        <tr><td>INC A</td><td>0x25</td><td>1</td><td>A++</td></tr>
        <tr><td>INC B</td><td>0x26</td><td>1</td><td>B++</td></tr>
        <tr><td>INC X</td><td>0x27</td><td>1</td><td>X++</td></tr>
        <tr><td>JMP addr</td><td>0x30 LL HH</td><td>3</td><td>PC = addr</td></tr>
        <tr><td>JE addr</td><td>0x31 LL HH</td><td>3</td><td>Zフラグ=1ならジャンプ</td></tr>
        <tr><td>JNE addr</td><td>0x32 LL HH</td><td>3</td><td>Zフラグ=0ならジャンプ</td></tr>
        <tr><td>HALT</td><td>0xFF</td><td>1</td><td>停止</td></tr>
      </tbody>
    </table>

    <div class="important">
      <strong>重要:</strong> アドレスはLittle Endian（下位バイトが先）。例: 0x8000 → <code>00 80</code>
    </div>

    <h2>4. 実装例（JavaScript）</h2>

    <h3>Step 1: 基本構造</h3>
    <pre>class SimpleXVM {
  constructor() {
    // レジスタ
    this.A = 0;
    this.B = 0;
    this.X = 0;
    this.PC = 0xE000;
    this.F = 0;
    
    // メモリ
    this.ram = new Uint8Array(0x8000);    // 32KB RAM
    this.vram = new Uint8Array(0x4000);   // 16KB VRAM
    this.palette = new Uint8Array(16);    // 16色パレット
    this.rom = new Uint8Array(0x2000);    // 8KB ROM
    
    // デフォルトパレット設定
    this.palette[0] = 0x00; // 黒
    this.palette[1] = 0xFF; // 白
    this.palette[2] = 0xE0; // 赤
    this.palette[3] = 0x1C; // 緑
    this.palette[4] = 0x03; // 青
    this.palette[5] = 0xFC; // 黄
    this.palette[6] = 0xE3; // マゼンタ
    this.palette[7] = 0x1F; // シアン
    
    this.halted = false;
    this.cycles = 0;
  }
}</pre>

    <h3>Step 2: メモリアクセス</h3>
    <pre>read8(addr) {
  addr &= 0xFFFF;
  if (addr < 0x8000) return this.ram[addr];
  if (addr < 0xC000) return this.vram[addr - 0x8000];
  if (addr < 0xC010) return this.palette[addr - 0xC000];
  if (addr >= 0xE000) return this.rom[addr - 0xE000];
  return 0;
}

write8(addr, val) {
  addr &= 0xFFFF;
  val &= 0xFF;
  if (addr < 0x8000) this.ram[addr] = val;
  else if (addr < 0xC000) this.vram[addr - 0x8000] = val;
  else if (addr < 0xC010) this.palette[addr - 0xC000] = val;
}

read16(addr) {
  return this.read8(addr) | (this.read8(addr + 1) << 8);
}</pre>

    <h3>Step 3: 命令実行</h3>
    <pre>step() {
  if (this.halted) return;
  
  const opcode = this.read8(this.PC++);
  
  switch(opcode) {
    case 0x00: // NOP
      break;
      
    case 0x01: // LD A, #n
      this.A = this.read8(this.PC++);
      this.updateZero(this.A);
      break;
      
    case 0x02: // LD B, #n
      this.B = this.read8(this.PC++);
      this.updateZero(this.B);
      break;
      
    case 0x03: // LD X, #n
      this.X = this.read8(this.PC++);
      this.updateZero(this.X);
      break;
      
    case 0x04: // LD A, [addr]
      this.A = this.read8(this.read16(this.PC));
      this.PC += 2;
      this.updateZero(this.A);
      break;
      
    case 0x05: // ST A, [addr]
      this.write8(this.read16(this.PC), this.A);
      this.PC += 2;
      break;
      
    case 0x10: // MOV A, B
      this.A = this.B;
      this.updateZero(this.A);
      break;
      
    case 0x11: // MOV B, A
      this.B = this.A;
      this.updateZero(this.B);
      break;
      
    case 0x12: // MOV A, X
      this.A = this.X;
      this.updateZero(this.A);
      break;
      
    case 0x13: // MOV X, A
      this.X = this.A;
      this.updateZero(this.X);
      break;
      
    case 0x20: // ADD A, B
      this.A = (this.A + this.B) & 0xFF;
      this.updateZero(this.A);
      break;
      
    case 0x25: // INC A
      this.A = (this.A + 1) & 0xFF;
      this.updateZero(this.A);
      break;
      
    case 0x26: // INC B
      this.B = (this.B + 1) & 0xFF;
      this.updateZero(this.B);
      break;
      
    case 0x27: // INC X
      this.X = (this.X + 1) & 0xFF;
      this.updateZero(this.X);
      break;
      
    case 0x30: // JMP addr
      this.PC = this.read16(this.PC);
      break;
      
    case 0x31: // JE addr
      const jeAddr = this.read16(this.PC);
      this.PC += 2;
      if (this.F & 0x01) this.PC = jeAddr;
      break;
      
    case 0x32: // JNE addr
      const jneAddr = this.read16(this.PC);
      this.PC += 2;
      if (!(this.F & 0x01)) this.PC = jneAddr;
      break;
      
    case 0xFF: // HALT
      this.halted = true;
      break;
  }
}

updateZero(val) {
  this.F = (val === 0) ? (this.F | 0x01) : (this.F & ~0x01);
}</pre>

    <h3>Step 4: 画面描画</h3>
    <pre>updateDisplay(canvas) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(128, 128);
  const pixels = imageData.data;
  
  for (let y = 0; y < 128; y++) {
    for (let x = 0; x < 128; x++) {
      const colorIdx = this.vram[y * 128 + x] & 0x0F;
      const rgb332 = this.palette[colorIdx];
      const [r, g, b] = this.rgb332ToRGB(rgb332);
      
      const offset = (y * 128 + x) * 4;
      pixels[offset] = r;
      pixels[offset + 1] = g;
      pixels[offset + 2] = b;
      pixels[offset + 3] = 255;
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

rgb332ToRGB(val) {
  const r = ((val >> 5) & 0x07) * 36;
  const g = ((val >> 2) & 0x07) * 36;
  const b = (val & 0x03) * 85;
  return [r, g, b];
}</pre>

    <h3>Step 5: メインループ</h3>
    <pre>run(canvas) {
  const runFrame = () => {
    const cyclesPerFrame = 16667; // 1MHz / 60Hz
    const start = this.cycles;
    
    while (this.cycles - start < cyclesPerFrame && !this.halted) {
      this.step();
      this.cycles++;
    }
    
    this.updateDisplay(canvas);
    
    if (!this.halted) {
      requestAnimationFrame(runFrame);
    }
  };
  
  runFrame();
}

// ROMロード
loadROM(data) {
  this.rom.set(data);
  this.PC = 0xE000;
  this.halted = false;
}</pre>

    <h2>5. サンプルプログラム</h2>

    <h3>例1: 画面を赤で塗りつぶす</h3>
    <pre>; 赤色(パレット2番)で画面全体を塗る
LD A, #2           ; 0x01 0x02 (色番号2=赤)
LD X, #0           ; 0x03 0x00 (カウンタ初期化)

LOOP:
  ST A, [0x8000]   ; 0x05 00 80 (VRAM先頭に書き込み)
  ; ※実際はXを使ってアドレスを計算する必要あり
  ; 簡易版では固定アドレスへの書き込みのみ
  INC X            ; 0x27
  LD B, #0         ; 0x02 0x00
  ; X == 0 になったら終了 (256回ループ)
  MOV B, X         ; 0x11
  ; Bが0ならZ=1
  JNE LOOP         ; 0x32 [LOOPアドレス]
  
HALT               ; 0xFF

機械語:
01 02 03 00 05 00 80 27 02 00 11 32 05 E0 FF</pre>

    <h3>例2: グラデーション描画</h3>
    <pre>; 0-15の色でグラデーション
LD A, #0           ; 0x01 0x00
LD X, #0           ; 0x03 0x00

OUTER:
  LD B, #128       ; 0x02 0x80 (128ピクセル)
  INNER:
    ; ST A, [VRAM + offset] を実装
    ; 簡易版では直接計算が必要
    INC B          ; 0x26
    JNE INNER      ; 0x32 [INNERアドレス]
  
  INC A            ; 0x25
  LD B, #16        ; 0x02 0x10
  ; A < 16 ?
  MOV B, A         ; 0x11
  ; ... 比較ロジック
  JNE OUTER        ; 0x32 [OUTERアドレス]

HALT               ; 0xFF</pre>

    <div class="note">
      <strong>実装のヒント:</strong> インデックスレジスタXを使った間接アドレッシングを追加すると、より柔軟なVRAM操作が可能になります。
    </div>

    <h2>6. 完成までのステップ</h2>

    <ol>
      <li><strong>1時間目:</strong> メモリアクセス関数を実装</li>
      <li><strong>2時間目:</strong> 基本命令(LD, ST, MOV)を実装</li>
      <li><strong>3時間目:</strong> 算術・ジャンプ命令を実装</li>
      <li><strong>4時間目:</strong> 画面描画機能を実装</li>
      <li><strong>5時間目:</strong> テストプログラムで動作確認</li>
    </ol>

    <div class="important">
      <strong>完成目標:</strong> 5時間で動作するエミュレータを実装し、画面に絵を描くプログラムを動かす!
    </div>

    <h2>7. 発展課題</h2>

    <ul>
      <li>キーボード入力対応（I/Oポート追加）</li>
      <li>スプライト機能（専用VRAM領域）</li>
      <li>サウンド機能（単純な矩形波）</li>
      <li>アセンブラの実装</li>
      <li>簡易BASICインタプリタ</li>
    </ul>

    <div style="margin-top: 50px; padding: 20px; background: #0a0a0a; border: 1px solid #0f0; text-align: center;">
      <h3 style="color: #0f0; margin-top: 0;">XVM-8S 仕様書</h3>
      <p style="color: #888;">誰でも実装できる最小限の8bitマシン</p>
      <p style="color: #0ff; font-size: 12px;">
        CC0 Public Domain - 自由に使用・改変・配布できます
      </p>
    </div>

  </div>
</body>
</html>