<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>XVM-16 Lite Complete Specification (MIDI Support)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
    }
    @font-face {
        font-family: "Renner";
        src: url("./Renner.ttf") format("truetype");
        font-display: swap;
      }
    body {
      background: #000;
      font-family: "Renner",sans-serif;
      margin: 0;
      padding: 20px;
      color: #fff;
      line-height: 1.6;
    }
    h1 {
      font-size: 32px;
      font-weight: 300;
      border-bottom: 2px solid #0f0;
      padding-bottom: 10px;
    }
    h2 {
      font-size: 24px;
      font-weight: 400;
      color: #0ff;
      margin-top: 40px;
    }
    h3 {
      font-size: 20px;
      font-weight: 400;
      color: #ff0;
      margin-top: 30px;
    }
    h4 {
      font-size: 16px;
      font-weight: 500;
      color: #f0f;
      margin-top: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      font-size: 13px;
    }
    th, td {
      border: 1px solid #444;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background: #1a1a1a;
      font-weight: 500;
    }
    code {
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }
    pre {
      background: #0f0f0f;
      border: 1px solid #333;
      padding: 15px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    .note {
      background: #1a1a00;
      border-left: 4px solid #ff0;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .important {
      background: #1a0000;
      border-left: 4px solid #f00;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .info {
      background: #001a1a;
      border-left: 4px solid #0ff;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .spec-box {
      background: #0a0a0a;
      border: 2px solid #0f0;
      padding: 20px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>XVM-16 Lite Complete Specification (MIDI Support)</h1>
    <p style="color: #888;">Complete Emulator Implementation Guide - 25 Instructions + MIDI</p>

    <div class="spec-box">
      <strong style="color: #0f0;">About This Specification:</strong><br>
      This document contains all information needed to implement an XVM-16 Lite virtual machine emulator.
      The instruction set is reduced to 25 for ease of learning and implementation, while maintaining practical game development capability.
    </div>

    <h2>1. Hardware Specifications</h2>
    
    <h3>1.1 CPU Specifications</h3>
    <table>
      <tr><th>Item</th><th>Specification</th></tr>
      <tr><td>Bit Width</td><td>8-bit CPU</td></tr>
      <tr><td>Address Space</td><td>16-bit (64KB = 65,536 bytes)</td></tr>
      <tr><td>Clock Speed</td><td>4MHz (4,000,000 Hz)</td></tr>
      <tr><td>Refresh Rate</td><td>60Hz (60 frames per second)</td></tr>
      <tr><td>Cycles per Frame</td><td>66,667 cycles (4,000,000 ÷ 60)</td></tr>
      <tr><td>Endianness</td><td>Little-endian (low byte first)</td></tr>
    </table>

    <h3>1.2 Registers</h3>
    <table>
      <tr><th>Name</th><th>Size</th><th>Initial</th><th>Description</th></tr>
      <tr><td><code>A</code></td><td>8-bit</td><td>0x00</td><td>Accumulator. Stores arithmetic operation results</td></tr>
      <tr><td><code>X</code></td><td>8-bit</td><td>0x00</td><td>X Index Register. Used for array access, etc.</td></tr>
      <tr><td><code>Y</code></td><td>8-bit</td><td>0x00</td><td>Y Index Register. Used for array access, etc.</td></tr>
      <tr><td><code>SP</code></td><td>16-bit</td><td>0x01FF</td><td>Stack Pointer. Grows downward (decrements)</td></tr>
      <tr><td><code>PC</code></td><td>16-bit</td><td>0xE000</td><td>Program Counter. Address of next instruction to execute</td></tr>
      <tr><td><code>F</code></td><td>8-bit</td><td>0x00</td><td>Flag Register. Holds operation result status</td></tr>
    </table>

    <h4>Flag Register (F) Details</h4>
    <table>
      <tr><th>Bit</th><th>Name</th><th>Description</th><th>Set Condition</th></tr>
      <tr><td>bit 0</td><td>Z (Zero)</td><td>Zero flag</td><td>Set to 1 when result is 0x00</td></tr>
      <tr><td>bit 1</td><td>C (Carry)</td><td>Carry flag</td><td>Set to 1 on addition carry or subtraction no-borrow</td></tr>
      <tr><td>bit 2</td><td>N (Negative)</td><td>Negative flag</td><td>Set to 1 when bit7 of result is 1 (signed negative)</td></tr>
      <tr><td>bit 3-7</td><td>-</td><td>Unused</td><td>Always 0</td></tr>
    </table>

    <h3>1.3 Memory Map</h3>
    <table>
      <tr><th>Start</th><th>End</th><th>Size</th><th>Name</th><th>Purpose</th><th>Read</th><th>Write</th></tr>
      <tr><td>0x0000</td><td>0x00FF</td><td>256B</td><td>Zero Page RAM</td><td>Fast access variable area</td><td>✓</td><td>✓</td></tr>
      <tr><td>0x0100</td><td>0x01FF</td><td>256B</td><td>Stack</td><td>Subroutine calls</td><td>✓</td><td>✓</td></tr>
      <tr><td>0x0200</td><td>0x1FFF</td><td>7.5KB</td><td>General RAM</td><td>Program work area</td><td>✓</td><td>✓</td></tr>
      <tr><td>0x2000</td><td>0x5FFF</td><td>16KB</td><td>Sprite Tiles</td><td>256 tiles of 16x16</td><td>✓</td><td>✓</td></tr>
      <tr><td>0x6000</td><td>0x7FFF</td><td>8KB</td><td>General RAM</td><td>Additional work area</td><td>✓</td><td>✓</td></tr>
      <tr><td>0x8000</td><td>0xFFFF</td><td>32KB</td><td>VRAM</td><td>256x256 pixel data</td><td>✓</td><td>✓</td></tr>
      <tr><td>0xD000</td><td>0xD0FF</td><td>256B</td><td>Palette</td><td>256 colors RGB332</td><td>✓</td><td>✓</td></tr>
      <tr><td>0xD100</td><td>0xD1FF</td><td>256B</td><td>Sprite Attrs</td><td>64 sprites x 4 bytes</td><td>✓</td><td>✓</td></tr>
      <tr><td>0xD200</td><td>0xD2FF</td><td>256B</td><td>MIDI</td><td>MIDI control registers</td><td>✓</td><td>✓</td></tr>
      <tr><td>0xD300</td><td>0xD3FF</td><td>256B</td><td>I/O</td><td>Input and misc</td><td>✓</td><td>△</td></tr>
      <tr><td>0xE000</td><td>0xFFFF</td><td>8KB</td><td>ROM</td><td>Program code</td><td>✓</td><td>×</td></tr>
    </table>

    <div class="important">
      <strong>Memory Overlap:</strong><br>
      The 0xD000-0xDFFF region physically overlaps with VRAM space (0x8000-0xFFFF).<br>
      - On read: Returns I/O register/palette/sprite attribute values<br>
      - On write: Writes to both I/O registers/palette/sprite attributes AND VRAM
    </div>

    <h2>2. Instruction Set (All 25 Instructions)</h2>

    <div class="spec-box">
      <strong>Instruction Format:</strong><br>
      Each instruction consists of 1-3 bytes.<br>
      - Opcode (1 byte): Instruction type<br>
      - Operand (0-2 bytes): Immediate data or address<br>
      Little-endian: 16-bit addresses are stored as low byte → high byte
    </div>

    <h3>2.1 Data Transfer Instructions (6 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th><th>Flags</th></tr>
      <tr><td>LDA #nn</td><td>0xA9</td><td>2</td><td>2</td><td>A ← nn (immediate)</td><td>Z,N</td></tr>
      <tr><td>LDA addr</td><td>0xAD</td><td>3</td><td>4</td><td>A ← [addr] (absolute)</td><td>Z,N</td></tr>
      <tr><td>LDA zp</td><td>0xA5</td><td>2</td><td>3</td><td>A ← [0x00zp] (zero page)</td><td>Z,N</td></tr>
      <tr><td>LDA addr,X</td><td>0xBD</td><td>3</td><td>4</td><td>A ← [addr+X] (indexed)</td><td>Z,N</td></tr>
      <tr><td>LDX #nn</td><td>0xA2</td><td>2</td><td>2</td><td>X ← nn (immediate)</td><td>Z,N</td></tr>
      <tr><td>LDX addr</td><td>0xAE</td><td>3</td><td>4</td><td>X ← [addr] (absolute)</td><td>Z,N</td></tr>
      <tr><td>LDX zp</td><td>0xA6</td><td>2</td><td>3</td><td>X ← [0x00zp] (zero page)</td><td>Z,N</td></tr>
      <tr><td>LDY #nn</td><td>0xA0</td><td>2</td><td>2</td><td>Y ← nn (immediate)</td><td>Z,N</td></tr>
      <tr><td>LDY addr</td><td>0xAC</td><td>3</td><td>4</td><td>Y ← [addr] (absolute)</td><td>Z,N</td></tr>
      <tr><td>LDY zp</td><td>0xA4</td><td>2</td><td>3</td><td>Y ← [0x00zp] (zero page)</td><td>Z,N</td></tr>
      <tr><td>STA addr</td><td>0x8D</td><td>3</td><td>4</td><td>[addr] ← A (absolute)</td><td>-</td></tr>
      <tr><td>STA zp</td><td>0x85</td><td>2</td><td>3</td><td>[0x00zp] ← A (zero page)</td><td>-</td></tr>
      <tr><td>STA addr,X</td><td>0x9D</td><td>3</td><td>5</td><td>[addr+X] ← A (indexed)</td><td>-</td></tr>
      <tr><td>STX addr</td><td>0x8E</td><td>3</td><td>4</td><td>[addr] ← X (absolute)</td><td>-</td></tr>
      <tr><td>STX zp</td><td>0x86</td><td>2</td><td>3</td><td>[0x00zp] ← X (zero page)</td><td>-</td></tr>
      <tr><td>STY addr</td><td>0x8C</td><td>3</td><td>4</td><td>[addr] ← Y (absolute)</td><td>-</td></tr>
      <tr><td>STY zp</td><td>0x84</td><td>2</td><td>3</td><td>[0x00zp] ← Y (zero page)</td><td>-</td></tr>
    </table>

    <div class="note">
      <strong>Implementation Notes:</strong><br>
      - zp is 8-bit address. Actual address is in range 0x0000-0x00FF<br>
      - addr is 16-bit address. Stored in little-endian (low→high)<br>
      - Index mode overflow: (addr + X) & 0xFFFF
    </div>

    <h3>2.2 Arithmetic Instructions (5 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th><th>Flags</th></tr>
      <tr><td>ADC #nn</td><td>0x69</td><td>2</td><td>2</td><td>A ← A + nn + C</td><td>Z,C,N</td></tr>
      <tr><td>ADC addr</td><td>0x6D</td><td>3</td><td>4</td><td>A ← A + [addr] + C</td><td>Z,C,N</td></tr>
      <tr><td>ADC zp</td><td>0x65</td><td>2</td><td>3</td><td>A ← A + [zp] + C</td><td>Z,C,N</td></tr>
      <tr><td>SBC #nn</td><td>0xE9</td><td>2</td><td>2</td><td>A ← A - nn - (1-C)</td><td>Z,C,N</td></tr>
      <tr><td>SBC addr</td><td>0xED</td><td>3</td><td>4</td><td>A ← A - [addr] - (1-C)</td><td>Z,C,N</td></tr>
      <tr><td>SBC zp</td><td>0xE5</td><td>2</td><td>3</td><td>A ← A - [zp] - (1-C)</td><td>Z,C,N</td></tr>
      <tr><td>AND #nn</td><td>0x29</td><td>2</td><td>2</td><td>A ← A & nn</td><td>Z,N</td></tr>
      <tr><td>AND addr</td><td>0x2D</td><td>3</td><td>4</td><td>A ← A & [addr]</td><td>Z,N</td></tr>
      <tr><td>AND zp</td><td>0x25</td><td>2</td><td>3</td><td>A ← A & [zp]</td><td>Z,N</td></tr>
      <tr><td>ORA #nn</td><td>0x09</td><td>2</td><td>2</td><td>A ← A | nn</td><td>Z,N</td></tr>
      <tr><td>ORA addr</td><td>0x0D</td><td>3</td><td>4</td><td>A ← A | [addr]</td><td>Z,N</td></tr>
      <tr><td>ORA zp</td><td>0x05</td><td>2</td><td>3</td><td>A ← A | [zp]</td><td>Z,N</td></tr>
      <tr><td>CMP #nn</td><td>0xC9</td><td>2</td><td>2</td><td>A - nn (compare, discard result)</td><td>Z,C,N</td></tr>
      <tr><td>CMP addr</td><td>0xCD</td><td>3</td><td>4</td><td>A - [addr] (compare)</td><td>Z,C,N</td></tr>
      <tr><td>CMP zp</td><td>0xC5</td><td>2</td><td>3</td><td>A - [zp] (compare)</td><td>Z,C,N</td></tr>
    </table>

    <div class="important">
      <strong>ADC/SBC Operation Details:</strong><br>
      <strong>ADC:</strong> result = A + operand + C; A = result & 0xFF; C = (result > 255) ? 1 : 0<br>
      <strong>SBC:</strong> result = A - operand - (1 - C); A = result & 0xFF; C = (result >= 0) ? 1 : 0<br>
      <strong>CMP:</strong> result = A - operand; C = (A >= operand) ? 1 : 0 (A is not modified)
    </div>

    <h3>2.3 Increment/Decrement (4 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th><th>Flags</th></tr>
      <tr><td>INC addr</td><td>0xEE</td><td>3</td><td>6</td><td>[addr] ← [addr] + 1</td><td>Z,N</td></tr>
      <tr><td>INC zp</td><td>0xE6</td><td>2</td><td>5</td><td>[zp] ← [zp] + 1</td><td>Z,N</td></tr>
      <tr><td>DEC addr</td><td>0xCE</td><td>3</td><td>6</td><td>[addr] ← [addr] - 1</td><td>Z,N</td></tr>
      <tr><td>DEC zp</td><td>0xC6</td><td>2</td><td>5</td><td>[zp] ← [zp] - 1</td><td>Z,N</td></tr>
      <tr><td>INX</td><td>0xE8</td><td>1</td><td>2</td><td>X ← X + 1</td><td>Z,N</td></tr>
      <tr><td>INY</td><td>0xC8</td><td>1</td><td>2</td><td>Y ← Y + 1</td><td>Z,N</td></tr>
      <tr><td>DEX</td><td>0xCA</td><td>1</td><td>2</td><td>X ← X - 1</td><td>Z,N</td></tr>
      <tr><td>DEY</td><td>0x88</td><td>1</td><td>2</td><td>Y ← Y - 1</td><td>Z,N</td></tr>
    </table>

    <h3>2.4 Branch Instructions (4 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th><th>Condition</th></tr>
      <tr><td>JMP addr</td><td>0x4C</td><td>3</td><td>3</td><td>PC ← addr (unconditional jump)</td><td>-</td></tr>
      <tr><td>BEQ rel</td><td>0xF0</td><td>2</td><td>2/3</td><td>If Z=1 then PC ← PC + rel</td><td>Z=1</td></tr>
      <tr><td>BNE rel</td><td>0xD0</td><td>2</td><td>2/3</td><td>If Z=0 then PC ← PC + rel</td><td>Z=0</td></tr>
      <tr><td>BCS rel</td><td>0xB0</td><td>2</td><td>2/3</td><td>If C=1 then PC ← PC + rel</td><td>C=1</td></tr>
      <tr><td>BCC rel</td><td>0x90</td><td>2</td><td>2/3</td><td>If C=0 then PC ← PC + rel</td><td>C=0</td></tr>
    </table>

    <div class="note">
      <strong>Relative Branch Details:</strong><br>
      - rel is signed 8-bit (-128 to +127)<br>
      - Negative values: if rel > 127 then interpret as rel - 256<br>
      - Branch target = PC + rel (PC already points to next instruction)<br>
      - Cycles: no branch=2, branch taken=3
    </div>

    <h3>2.5 Subroutine (2 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>JSR addr</td><td>0x20</td><td>3</td><td>6</td><td>Push PC-1 to stack and jump to addr</td></tr>
      <tr><td>RTS</td><td>0x60</td><td>1</td><td>6</td><td>Pop address from stack and return to PC+1</td></tr>
    </table>

    <div class="important">
      <strong>JSR/RTS Operation Details:</strong><br>
      <strong>JSR:</strong><br>
      1. return_addr = PC + 2 (next instruction after JSR)<br>
      2. [SP] = (return_addr - 1) >> 8 (high byte); SP--<br>
      3. [SP] = (return_addr - 1) & 0xFF (low byte); SP--<br>
      4. PC = addr<br>
      <strong>RTS:</strong><br>
      1. SP++; low = [SP]<br>
      2. SP++; high = [SP]<br>
      3. PC = (high << 8 | low) + 1
    </div>

    <h3>2.6 Stack (2 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>PHA</td><td>0x48</td><td>1</td><td>3</td><td>[SP] ← A; SP--</td></tr>
      <tr><td>PLA</td><td>0x68</td><td>1</td><td>4</td><td>SP++; A ← [SP]</td></tr>
    </table>

    <h3>2.7 Miscellaneous (2 instructions)</h3>
    <table>
      <tr><th>Instruction</th><th>Opcode</th><th>Bytes</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>NOP</td><td>0xEA</td><td>1</td><td>2</td><td>No operation</td></tr>
      <tr><td>BRK</td><td>0x00</td><td>1</td><td>7</td><td>Break (halt execution)</td></tr>
    </table>

    <h2>3. Graphics Specifications</h2>

    <h3>3.1 Display</h3>
    <table>
      <tr><th>Item</th><th>Specification</th></tr>
      <tr><td>Resolution</td><td>256x256 pixels</td></tr>
      <tr><td>Colors</td><td>256 colors (8-bit indexed color)</td></tr>
      <tr><td>VRAM Size</td><td>65,536 bytes (256×256)</td></tr>
      <tr><td>VRAM Address</td><td>0x8000-0xFFFF</td></tr>
      <tr><td>Pixel Access</td><td>VRAM[y * 256 + x] = color_index (0-255)</td></tr>
    </table>

    <h3>3.2 Color Palette</h3>
    <table>
      <tr><th>Item</th><th>Specification</th></tr>
      <tr><td>Address</td><td>0xD000-0xD0FF</td></tr>
      <tr><td>Format</td><td>RGB332 (8-bit)</td></tr>
      <tr><td>Bit Layout</td><td>RRRGGGBB</td></tr>
    </table>

    <h4>RGB332 to RGB888 Conversion</h4>
    <pre>uint8_t rgb332 = palette[color_index];
uint8_t r = ((rgb332 >> 5) & 0x07) * 36;  // 0-7 → 0-252
uint8_t g = ((rgb332 >> 2) & 0x07) * 36;  // 0-7 → 0-252
uint8_t b = (rgb332 & 0x03) * 85;         // 0-3 → 0-255</pre>

    <h4>Default Palette (0-15)</h4>
    <pre>const uint8_t default_palette[16] = {
  0x00, // 0:  Black
  0xFF, // 1:  White
  0xE0, // 2:  Red
  0x1C, // 3:  Green
  0x03, // 4:  Blue
  0xFC, // 5:  Yellow
  0xE3, // 6:  Magenta
  0x1F, // 7:  Cyan
  0x92, // 8:  Gray
  0x6D, // 9:  Brown
  0xB8, // 10: Orange
  0x9F, // 11: Lime
  0x13, // 12: Light Blue
  0xA3, // 13: Purple
  0xFD, // 14: Pink
  0xB6  // 15: Beige
};</pre>

    <h3>3.3 Sprites</h3>
    <table>
      <tr><th>Item</th><th>Specification</th></tr>
      <tr><td>Sprite Count</td><td>64 sprites</td></tr>
      <tr><td>Sprite Size</td><td>16x16 pixels (fixed)</td></tr>
      <tr><td>Attribute Table</td><td>0xD100-0xD1FF (4 bytes/sprite)</td></tr>
      <tr><td>Tile Data</td><td>0x2000-0x5FFF (256 tiles)</td></tr>
      <tr><td>Tile Size</td><td>256 bytes/tile (16x16)</td></tr>
    </table>

    <h4>Sprite Attributes (4-byte structure)</h4>
    <table>
      <tr><th>Offset</th><th>Name</th><th>Description</th></tr>
      <tr><td>+0</td><td>X coordinate</td><td>0-255 (X position on screen)</td></tr>
      <tr><td>+1</td><td>Y coordinate</td><td>0-255 (Y position on screen)</td></tr>
      <tr><td>+2</td><td>Tile number</td><td>0-255 (tile index to display)</td></tr>
      <tr><td>+3</td><td>Flags</td><td>bit0=enable, bit1=flip X, bit2=flip Y</td></tr>
    </table>

    <h4>Sprite Rendering Algorithm</h4>
    <pre>for (int sprite_id = 0; sprite_id < 64; sprite_id++) {
  uint8_t x = sprite_attr[sprite_id * 4 + 0];
  uint8_t y = sprite_attr[sprite_id * 4 + 1];
  uint8_t tile = sprite_attr[sprite_id * 4 + 2];
  uint8_t flags = sprite_attr[sprite_id * 4 + 3];
  
  if (!(flags & 0x01)) continue; // Skip if disabled
  
  bool flip_x = flags & 0x02;
  bool flip_y = flags & 0x04;
  
  uint8_t* tile_data = &sprite_tiles[tile * 256];
  
  for (int sy = 0; sy < 16; sy++) {
    for (int sx = 0; sx < 16; sx++) {
      uint8_t color_idx = tile_data[sy * 16 + sx];
      if (color_idx == 0) continue; // Transparent
      
      int px = x + (flip_x ? (15 - sx) : sx);
      int py = y + (flip_y ? (15 - sy) : sy);
      
      if (px >= 0 && px < 256 && py >= 0 && py < 256) {
        framebuffer[py * 256 + px] = palette[color_idx];
      }
    }
  }
}</pre>

    <h2>4. MIDI Sound Specifications</h2>

    <h3>4.1 MIDI Register Map</h3>
    <table>
      <tr><th>Address</th><th>Name</th><th>R/W</th><th>Description</th></tr>
      <tr><td>0xD200</td><td>MIDI_CMD</td><td>W</td><td>MIDI status byte (0x80-0xFF)</td></tr>
      <tr><td>0xD201</td><td>MIDI_DATA1</td><td>W</td><td>Data byte 1 (0x00-0x7F)</td></tr>
      <tr><td>0xD202</td><td>MIDI_DATA2</td><td>W</td><td>Data byte 2 (0x00-0x7F)</td></tr>
      <tr><td>0xD203</td><td>MIDI_SEND</td><td>W</td><td>Write to send MIDI message</td></tr>
      <tr><td>0xD204-0xD213</td><td>CH_PROGRAM[0-15]</td><td>W</td><td>Channel program (0-127)</td></tr>
      <tr><td>0xD214-0xD223</td><td>CH_VOLUME[0-15]</td><td>W</td><td>Channel volume (0-127)</td></tr>
      <tr><td>0xD224-0xD233</td><td>CH_PAN[0-15]</td><td>W</td><td>Channel pan (0-127, 64=center)</td></tr>
    </table>

    <h3>4.2 MIDI Message Format</h3>
    <table>
      <tr><th>Message</th><th>Status</th><th>Data 1</th><th>Data 2</th><th>Description</th></tr>
      <tr><td>Note Off</td><td>0x80-0x8F</td><td>Note number</td><td>Velocity</td><td>Stop note</td></tr>
      <tr><td>Note On</td><td>0x90-0x9F</td><td>Note number</td><td>Velocity</td><td>Start note</td></tr>
      <tr><td>Poly Aftertouch</td><td>0xA0-0xAF</td><td>Note number</td><td>Pressure</td><td>Key pressure</td></tr>
      <tr><td>Control Change</td><td>0xB0-0xBF</td><td>CC number</td><td>Value</td><td>Control change</td></tr>
      <tr><td>Program Change</td><td>0xC0-0xCF</td><td>Program number</td><td>-</td><td>Change instrument</td></tr>
      <tr><td>Channel Aftertouch</td><td>0xD0-0xDF</td><td>Pressure</td><td>-</td><td>Channel pressure</td></tr>
      <tr><td>Pitch Bend</td><td>0xE0-0xEF</td><td>LSB</td><td>MSB</td><td>Pitch bend</td></tr>
    </table>

    <div class="note">
      <strong>Channel Number Calculation:</strong><br>
      Lower 4 bits of status byte = channel number (0-15)<br>
      Example: 0x90 = Channel 1 Note On, 0x9F = Channel 16 Note On
    </div>

    <h3>4.3 MIDI Sending Procedure</h3>
    <pre>// Note On: Channel 1, C4(60), velocity 100
memory[0xD200] = 0x90;  // Note On, Ch1
memory[0xD201] = 60;    // Note number
memory[0xD202] = 100;   // Velocity
memory[0xD203] = 0x00;  // Trigger send

// Note Off: Channel 1, C4(60)
memory[0xD200] = 0x80;  // Note Off, Ch1
memory[0xD201] = 60;    // Note number
memory[0xD202] = 64;    // Release velocity
memory[0xD203] = 0x00;  // Trigger send

// Program Change: Channel 1 to program 1 (Piano)
memory[0xD204] = 1;     // Direct write
// or
memory[0xD200] = 0xC0;  // Program Change, Ch1
memory[0xD201] = 1;     // Program number
memory[0xD203] = 0x00;  // Trigger send</pre>

    <h3>4.4 MIDI Note Number Table</h3>
    <table>
      <tr><th>Note</th><th>Octave 2</th><th>Octave 3</th><th>Octave 4</th><th>Octave 5</th><th>Frequency(Hz)</th></tr>
      <tr><td>C</td><td>36</td><td>48</td><td>60</td><td>72</td><td>261.63</td></tr>
      <tr><td>C#/D♭</td><td>37</td><td>49</td><td>61</td><td>73</td><td>277.18</td></tr>
      <tr><td>D</td><td>38</td><td>50</td><td>62</td><td>74</td><td>293.66</td></tr>
      <tr><td>D#/E♭</td><td>39</td><td>51</td><td>63</td><td>75</td><td>311.13</td></tr>
      <tr><td>E</td><td>40</td><td>52</td><td>64</td><td>76</td><td>329.63</td></tr>
      <tr><td>F</td><td>41</td><td>53</td><td>65</td><td>77</td><td>349.23</td></tr>
      <tr><td>F#/G♭</td><td>42</td><td>54</td><td>66</td><td>78</td><td>369.99</td></tr>
      <tr><td>G</td><td>43</td><td>55</td><td>67</td><td>79</td><td>392.00</td></tr>
      <tr><td>G#/A♭</td><td>44</td><td>56</td><td>68</td><td>80</td><td>415.30</td></tr>
      <tr><td>A</td><td>45</td><td>57</td><td>69</td><td>81</td><td>440.00</td></tr>
      <tr><td>A#/B♭</td><td>46</td><td>58</td><td>70</td><td>82</td><td>466.16</td></tr>
      <tr><td>B</td><td>47</td><td>59</td><td>71</td><td>83</td><td>493.88</td></tr>
    </table>

    <h3>4.5 General MIDI Instrument Table (Excerpt)</h3>
    <table>
      <tr><th>Number</th><th>Instrument</th><th>Number</th><th>Instrument</th></tr>
      <tr><td>0</td><td>Acoustic Grand Piano</td><td>32</td><td>Acoustic Bass</td></tr>
      <tr><td>1</td><td>Bright Acoustic Piano</td><td>33</td><td>Electric Bass (finger)</td></tr>
      <tr><td>4</td><td>Electric Piano 1</td><td>40</td><td>Violin</td></tr>
      <tr><td>5</td><td>Electric Piano 2</td><td>56</td><td>Trumpet</td></tr>
      <tr><td>16</td><td>Drawbar Organ</td><td>65</td><td>Soprano Sax</td></tr>
      <tr><td>24</td><td>Acoustic Guitar (nylon)</td><td>73</td><td>Flute</td></tr>
      <tr><td>25</td><td>Acoustic Guitar (steel)</td><td>80</td><td>Lead 1 (square)</td></tr>
    </table>

    <h2>5. Input Specifications</h2>

    <h3>5.1 Controller Input</h3>
    <table>
      <tr><th>Address</th><th>Name</th><th>R/W</th><th>Description</th></tr>
      <tr><td>0xD300</td><td>CONTROLLER1</td><td>R</td><td>Controller 1 button states</td></tr>
      <tr><td>0xD301</td><td>CONTROLLER2</td><td>R</td><td>Controller 2 button states</td></tr>
    </table>

    <h4>Button Bit Layout</h4>
    <table>
      <tr><th>Bit</th><th>Button</th><th>Value</th></tr>
      <tr><td>bit 0</td><td>Up</td><td>0x01</td></tr>
      <tr><td>bit 1</td><td>Down</td><td>0x02</td></tr>
      <tr><td>bit 2</td><td>Left</td><td>0x04</td></tr>
      <tr><td>bit 3</td><td>Right</td><td>0x08</td></tr>
      <tr><td>bit 4</td><td>A</td><td>0x10</td></tr>
      <tr><td>bit 5</td><td>B</td><td>0x20</td></tr>
      <tr><td>bit 6</td><td>START</td><td>0x40</td></tr>
      <tr><td>bit 7</td><td>SELECT</td><td>0x80</td></tr>
    </table>

    <h4>Button Detection Example</h4>
    <pre>uint8_t input = memory[0xD300];
bool up_pressed = input & 0x01;
bool a_pressed = input & 0x10;
bool start_pressed = input & 0x40;</pre>

    <h3>5.2 Other I/O Registers</h3>
    <table>
      <tr><th>Address</th><th>Name</th><th>R/W</th><th>Description</th></tr>
      <tr><td>0xD302</td><td>RANDOM</td><td>R</td><td>Random value (0-255), updated on each read</td></tr>
      <tr><td>0xD303</td><td>FRAME_LOW</td><td>R</td><td>Frame counter low 8 bits</td></tr>
      <tr><td>0xD304</td><td>FRAME_HIGH</td><td>R</td><td>Frame counter high 8 bits</td></tr>
    </table>

    <h2>6. Sample Programs</h2>

    <h3>6.1 Screen Fill</h3>
    <pre>; Fill screen with red (palette #2)

E000: A9 02     LDA #$02      ; A = 2 (red)
E002: A2 00     LDX #$00      ; X = 0
E004: A0 00     LDY #$00      ; Y = 0

; Outer loop (Y = 0-255)
E006: A9 02     LDA #$02      ; A = 2
E008: 8D 00 80  STA $8000     ; VRAM[0x8000] = 2
E00B: E8        INX           ; X++
E00C: D0 F8     BNE $E006     ; If X != 0 goto E006
E00E: C8        INY           ; Y++
E00F: D0 F5     BNE $E006     ; If Y != 0 goto E006

E011: 00        BRK           ; Halt</pre>

    <h3>6.2 Play Scale</h3>
    <pre>; Play notes from C4 to C5 in sequence

E000: A2 3C     LDX #$3C      ; X = 60 (C4)

; Loop start
E002: A9 90     LDA #$90      ; Note On, Ch1
E004: 8D 00 D2  STA $D200
E007: 8E 01 D2  STX $D201     ; Note number
E00A: A9 64     LDA #$64      ; Velocity 100
E00C: 8D 02 D2  STA $D202
E00F: A9 00     LDA #$00
E011: 8D 03 D2  STA $D203     ; Send

; Wait 60 frames (simplified)
E014: A0 3C     LDY #$3C      ; Y = 60
E016: 88        DEY           ; Y--
E017: D0 FD     BNE $E016     ; If Y != 0 goto E016

; Note Off
E019: A9 80     LDA #$80      ; Note Off, Ch1
E01B: 8D 00 D2  STA $D200
E01E: 8E 01 D2  STX $D201
E021: A9 40     LDA #$40
E023: 8D 02 D2  STA $D202
E026: A9 00     LDA #$00
E028: 8D 03 D2  STA $D203

E02B: E8        INX           ; Next note
E02C: E0 49     CPX #$49      ; X == 73 (C5)?
E02E: D0 D2     BNE $E002     ; Continue if not

E030: 00        BRK           ; Halt</pre>

    <div style="margin-top: 50px; padding: 25px; background: #0a0a0a; border: 2px solid #0f0; text-align: center;">
      <h3 style="color: #0f0; margin-top: 0;">XVM-16 Lite Complete Specification v1.0</h3>
      <p style="color: #888; margin: 10px 0;">
        256x256 resolution | 256 colors | MIDI 16ch | 64 sprites<br>
        25 instruction set | Full emulator implementation support
      </p>
      <p style="color: #0ff; font-size: 12px; margin-top: 15px;">
        CC0 Public Domain - Free to use, modify, and distribute
      </p>
    </div>

  </div>
</body>
</html>
